{"version":3,"file":"gfm-blockquote-admonitions.js","sources":["../node_modules/unist-util-is/lib/index.js","../node_modules/unist-util-visit-parents/lib/color.js","../node_modules/unist-util-visit-parents/lib/index.js","../node_modules/unist-util-visit/lib/index.js","../src/config.ts","../src/remark-gfm-blockquote-admonitions/index.ts","../src/gfm-blockquote-admonitions.ts"],"sourcesContent":["/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n */\n\n/**\n * @template Fn\n * @template Fallback\n * @typedef {Fn extends (value: any) => value is infer Thing ? Thing : Fallback} Predicate\n */\n\n/**\n * @callback Check\n *   Check that an arbitrary value is a node.\n * @param {unknown} this\n *   The given context.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The nodeâ€™s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The nodeâ€™s parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n *\n * @typedef {Record<string, unknown> | Node} Props\n *   Object to check for equivalence.\n *\n *   Note: `Node` is included as it is common but is not indexable.\n *\n * @typedef {Array<Props | TestFunction | string> | Props | TestFunction | string | null | undefined} Test\n *   Check for an arbitrary node.\n *\n * @callback TestFunction\n *   Check if a node passes a test.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | undefined} [index]\n *   The nodeâ€™s position in its parent.\n * @param {Parent | undefined} [parent]\n *   The nodeâ€™s parent.\n * @returns {boolean | undefined | void}\n *   Whether this node passes the test.\n *\n *   Note: `void` is included until TS sees no return as `undefined`.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param {unknown} node\n *   Thing to check, typically `Node`.\n * @param {Test} test\n *   A check for a specific node.\n * @param {number | null | undefined} index\n *   The nodeâ€™s position in its parent.\n * @param {Parent | null | undefined} parent\n *   The nodeâ€™s parent.\n * @param {unknown} context\n *   Context object (`this`) to pass to `test` functions.\n * @returns {boolean}\n *   Whether `node` is a node and passes a test.\n */\nexport const is =\n  // Note: overloads in JSDoc canâ€™t yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends string>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((node?: null | undefined) => false) &\n   *   ((node: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((node: unknown, test?: Test, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function (node, test, index, parent, context) {\n      const check = convert(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!is(parent) || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      return looksLikeANode(node)\n        ? check.call(context, node, index, parent)\n        : false\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if youâ€™re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param {Test} test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns {Check}\n *   An assertion.\n */\nexport const convert =\n  // Note: overloads in JSDoc canâ€™t yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((test?: Test) => Check)\n   * )}\n   */\n  (\n    /**\n     * @param {Test} [test]\n     * @returns {Check}\n     */\n    function (test) {\n      if (test === null || test === undefined) {\n        return ok\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\n      }\n\n      if (typeof test === 'string') {\n        return typeFactory(test)\n      }\n\n      throw new Error('Expected function, string, or object as test')\n    }\n  )\n\n/**\n * @param {Array<Props | TestFunction | string>} tests\n * @returns {Check}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<Check>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @type {TestFunction}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].apply(this, parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {Check}\n */\nfunction propsFactory(check) {\n  const checkAsRecord = /** @type {Record<string, unknown>} */ (check)\n\n  return castFactory(all)\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function all(node) {\n    const nodeAsRecord = /** @type {Record<string, unknown>} */ (\n      /** @type {unknown} */ (node)\n    )\n\n    /** @type {string} */\n    let key\n\n    for (key in check) {\n      if (nodeAsRecord[key] !== checkAsRecord[key]) return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {Check}\n */\nfunction typeFactory(check) {\n  return castFactory(type)\n\n  /**\n   * @param {Node} node\n   */\n  function type(node) {\n    return node && node.type === check\n  }\n}\n\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunction} testFunction\n * @returns {Check}\n */\nfunction castFactory(testFunction) {\n  return check\n\n  /**\n   * @this {unknown}\n   * @type {Check}\n   */\n  function check(value, index, parent) {\n    return Boolean(\n      looksLikeANode(value) &&\n        testFunction.call(\n          this,\n          value,\n          typeof index === 'number' ? index : undefined,\n          parent || undefined\n        )\n    )\n  }\n}\n\nfunction ok() {\n  return true\n}\n\n/**\n * @param {unknown} value\n * @returns {value is Node}\n */\nfunction looksLikeANode(value) {\n  return value !== null && typeof value === 'object' && 'type' in value\n}\n","/**\n * @param {string} d\n * @returns {string}\n */\nexport function color(d) {\n  return d\n}\n","/**\n * @typedef {import('unist').Node} UnistNode\n * @typedef {import('unist').Parent} UnistParent\n */\n\n/**\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesnâ€™t work when publishing on npm.\n */\n\n/**\n * @typedef {(\n *   Fn extends (value: any) => value is infer Thing\n *   ? Thing\n *   : Fallback\n * )} Predicate\n *   Get the value of a type guard `Fn`.\n * @template Fn\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\n * @template Fallback\n *   Value to yield if `Fn` is not a type guard.\n */\n\n/**\n * @typedef {(\n *   Check extends null | undefined // No test.\n *   ? Value\n *   : Value extends {type: Check} // String (type) test.\n *   ? Value\n *   : Value extends Check // Partial test.\n *   ? Value\n *   : Check extends Function // Function test.\n *   ? Predicate<Check, Value> extends Value\n *     ? Predicate<Check, Value>\n *     : never\n *   : never // Some other test?\n * )} MatchesOne\n *   Check whether a node matches a primitive check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\n */\n\n/**\n * @typedef {(\n *   Check extends Array<any>\n *   ? MatchesOne<Value, Check[keyof Check]>\n *   : MatchesOne<Value, Check>\n * )} Matches\n *   Check whether a node matches a check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test.\n */\n\n/**\n * @typedef {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10} Uint\n *   Number; capped reasonably.\n */\n\n/**\n * @typedef {I extends 0 ? 1 : I extends 1 ? 2 : I extends 2 ? 3 : I extends 3 ? 4 : I extends 4 ? 5 : I extends 5 ? 6 : I extends 6 ? 7 : I extends 7 ? 8 : I extends 8 ? 9 : 10} Increment\n *   Increment a number in the type system.\n * @template {Uint} [I=0]\n *   Index.\n */\n\n/**\n * @typedef {(\n *   Node extends UnistParent\n *   ? Node extends {children: Array<infer Children>}\n *     ? Child extends Children ? Node : never\n *     : never\n *   : never\n * )} InternalParent\n *   Collect nodes that can be parents of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {InternalParent<InclusiveDescendant<Tree>, Child>} Parent\n *   Collect nodes in `Tree` that can be parents of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Depth extends Max\n *   ? never\n *   :\n *     | InternalParent<Node, Child>\n *     | InternalAncestor<Node, InternalParent<Node, Child>, Max, Increment<Depth>>\n * )} InternalAncestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {InternalAncestor<InclusiveDescendant<Tree>, Child>} Ancestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Tree extends UnistParent\n *     ? Depth extends Max\n *       ? Tree\n *       : Tree | InclusiveDescendant<Tree['children'][number], Max, Increment<Depth>>\n *     : Tree\n * )} InclusiveDescendant\n *   Collect all (inclusive) descendants of `Tree`.\n *\n *   > ðŸ‘‰ **Note**: for performance reasons, this seems to be the fastest way to\n *   > recurse without actually running into an infinite loop, which the\n *   > previous version did.\n *   >\n *   > Practically, a max of `2` is typically enough assuming a `Root` is\n *   > passed, but it doesnâ€™t improve performance.\n *   > It gets higher with `List > ListItem > Table > TableRow > TableCell`.\n *   > Using up to `10` doesnâ€™t hurt or help either.\n * @template {UnistNode} Tree\n *   Tree type.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {'skip' | boolean} Action\n *   Union of the action types.\n *\n * @typedef {number} Index\n *   Move to the sibling at `index` next (after node itself is completely\n *   traversed).\n *\n *   Useful if mutating the tree, such as removing the node the visitor is\n *   currently on, or any of its previous siblings.\n *   Results less than 0 or greater than or equal to `children.length` stop\n *   traversing the parent.\n *\n * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple\n *   List with one or two values, the first an action, the second an index.\n *\n * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult\n *   Any value that can be returned from a visitor.\n */\n\n/**\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform the parent of node (the last of `ancestors`).\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of an ancestor still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Array<VisitedParents>} ancestors\n *   Ancestors of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n * @template {UnistNode} [Visited=UnistNode]\n *   Visited node type.\n * @template {UnistParent} [VisitedParents=UnistParent]\n *   Ancestor type.\n */\n\n/**\n * @typedef {Visitor<Matches<InclusiveDescendant<Tree>, Check>, Ancestor<Tree, Matches<InclusiveDescendant<Tree>, Check>>>} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parents`.\n * @template {UnistNode} [Tree=UnistNode]\n *   Tree type.\n * @template {Test} [Check=Test]\n *   Test type.\n */\n\nimport {convert} from 'unist-util-is'\nimport {color} from 'unist-util-visit-parents/do-not-use-color'\n\n/** @type {Readonly<ActionTuple>} */\nconst empty = []\n\n/**\n * Continue traversing as normal.\n */\nexport const CONTINUE = true\n\n/**\n * Stop traversing immediately.\n */\nexport const EXIT = false\n\n/**\n * Do not traverse this nodeâ€™s children.\n */\nexport const SKIP = 'skip'\n\n/**\n * Visit nodes, with ancestral information.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @overload\n * @param {Tree} tree\n * @param {Check} check\n * @param {BuildVisitor<Tree, Check>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @overload\n * @param {Tree} tree\n * @param {BuildVisitor<Tree>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @param {UnistNode} tree\n *   Tree to traverse.\n * @param {Visitor | Test} test\n *   `unist-util-is`-compatible test\n * @param {Visitor | boolean | null | undefined} [visitor]\n *   Handle each node.\n * @param {boolean | null | undefined} [reverse]\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns {undefined}\n *   Nothing.\n *\n * @template {UnistNode} Tree\n *   Node type.\n * @template {Test} Check\n *   `unist-util-is`-compatible test.\n */\nexport function visitParents(tree, test, visitor, reverse) {\n  /** @type {Test} */\n  let check\n\n  if (typeof test === 'function' && typeof visitor !== 'function') {\n    reverse = visitor\n    // @ts-expect-error no visitor given, so `visitor` is test.\n    visitor = test\n  } else {\n    // @ts-expect-error visitor given, so `test` isnâ€™t a visitor.\n    check = test\n  }\n\n  const is = convert(check)\n  const step = reverse ? -1 : 1\n\n  factory(tree, undefined, [])()\n\n  /**\n   * @param {UnistNode} node\n   * @param {number | undefined} index\n   * @param {Array<UnistParent>} parents\n   */\n  function factory(node, index, parents) {\n    const value = /** @type {Record<string, unknown>} */ (\n      node && typeof node === 'object' ? node : {}\n    )\n\n    if (typeof value.type === 'string') {\n      const name =\n        // `hast`\n        typeof value.tagName === 'string'\n          ? value.tagName\n          : // `xast`\n          typeof value.name === 'string'\n          ? value.name\n          : undefined\n\n      Object.defineProperty(visit, 'name', {\n        value:\n          'node (' + color(node.type + (name ? '<' + name + '>' : '')) + ')'\n      })\n    }\n\n    return visit\n\n    function visit() {\n      /** @type {Readonly<ActionTuple>} */\n      let result = empty\n      /** @type {Readonly<ActionTuple>} */\n      let subresult\n      /** @type {number} */\n      let offset\n      /** @type {Array<UnistParent>} */\n      let grandparents\n\n      if (!test || is(node, index, parents[parents.length - 1] || undefined)) {\n        // @ts-expect-error: `visitor` is now a visitor.\n        result = toResult(visitor(node, parents))\n\n        if (result[0] === EXIT) {\n          return result\n        }\n      }\n\n      if ('children' in node && node.children) {\n        const nodeAsParent = /** @type {UnistParent} */ (node)\n\n        if (nodeAsParent.children && result[0] !== SKIP) {\n          offset = (reverse ? nodeAsParent.children.length : -1) + step\n          grandparents = parents.concat(nodeAsParent)\n\n          while (offset > -1 && offset < nodeAsParent.children.length) {\n            const child = nodeAsParent.children[offset]\n\n            subresult = factory(child, offset, grandparents)()\n\n            if (subresult[0] === EXIT) {\n              return subresult\n            }\n\n            offset =\n              typeof subresult[1] === 'number' ? subresult[1] : offset + step\n          }\n        }\n      }\n\n      return result\n    }\n  }\n}\n\n/**\n * Turn a return value into a clean result.\n *\n * @param {VisitorResult} value\n *   Valid return values from visitors.\n * @returns {Readonly<ActionTuple>}\n *   Clean result.\n */\nfunction toResult(value) {\n  if (Array.isArray(value)) {\n    return value\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value]\n  }\n\n  return value === null || value === undefined ? empty : [value]\n}\n","/**\n * @typedef {import('unist').Node} UnistNode\n * @typedef {import('unist').Parent} UnistParent\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */\n\n/**\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesnâ€™t work when publishing on npm.\n */\n\n// To do: use types from `unist-util-visit-parents` when itâ€™s released.\n\n/**\n * @typedef {(\n *   Fn extends (value: any) => value is infer Thing\n *   ? Thing\n *   : Fallback\n * )} Predicate\n *   Get the value of a type guard `Fn`.\n * @template Fn\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\n * @template Fallback\n *   Value to yield if `Fn` is not a type guard.\n */\n\n/**\n * @typedef {(\n *   Check extends null | undefined // No test.\n *   ? Value\n *   : Value extends {type: Check} // String (type) test.\n *   ? Value\n *   : Value extends Check // Partial test.\n *   ? Value\n *   : Check extends Function // Function test.\n *   ? Predicate<Check, Value> extends Value\n *     ? Predicate<Check, Value>\n *     : never\n *   : never // Some other test?\n * )} MatchesOne\n *   Check whether a node matches a primitive check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\n */\n\n/**\n * @typedef {(\n *   Check extends Array<any>\n *   ? MatchesOne<Value, Check[keyof Check]>\n *   : MatchesOne<Value, Check>\n * )} Matches\n *   Check whether a node matches a check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test.\n */\n\n/**\n * @typedef {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10} Uint\n *   Number; capped reasonably.\n */\n\n/**\n * @typedef {I extends 0 ? 1 : I extends 1 ? 2 : I extends 2 ? 3 : I extends 3 ? 4 : I extends 4 ? 5 : I extends 5 ? 6 : I extends 6 ? 7 : I extends 7 ? 8 : I extends 8 ? 9 : 10} Increment\n *   Increment a number in the type system.\n * @template {Uint} [I=0]\n *   Index.\n */\n\n/**\n * @typedef {(\n *   Node extends UnistParent\n *   ? Node extends {children: Array<infer Children>}\n *     ? Child extends Children ? Node : never\n *     : never\n *   : never\n * )} InternalParent\n *   Collect nodes that can be parents of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {InternalParent<InclusiveDescendant<Tree>, Child>} Parent\n *   Collect nodes in `Tree` that can be parents of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Depth extends Max\n *   ? never\n *   :\n *     | InternalParent<Node, Child>\n *     | InternalAncestor<Node, InternalParent<Node, Child>, Max, Increment<Depth>>\n * )} InternalAncestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {(\n *   Tree extends UnistParent\n *     ? Depth extends Max\n *       ? Tree\n *       : Tree | InclusiveDescendant<Tree['children'][number], Max, Increment<Depth>>\n *     : Tree\n * )} InclusiveDescendant\n *   Collect all (inclusive) descendants of `Tree`.\n *\n *   > ðŸ‘‰ **Note**: for performance reasons, this seems to be the fastest way to\n *   > recurse without actually running into an infinite loop, which the\n *   > previous version did.\n *   >\n *   > Practically, a max of `2` is typically enough assuming a `Root` is\n *   > passed, but it doesnâ€™t improve performance.\n *   > It gets higher with `List > ListItem > Table > TableRow > TableCell`.\n *   > Using up to `10` doesnâ€™t hurt or help either.\n * @template {UnistNode} Tree\n *   Tree type.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform `parent`.\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of `parent` still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Visited extends UnistNode ? number | undefined : never} index\n *   Index of `node` in `parent`.\n * @param {Ancestor extends UnistParent ? Ancestor | undefined : never} parent\n *   Parent of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n * @template {UnistNode} [Visited=UnistNode]\n *   Visited node type.\n * @template {UnistParent} [Ancestor=UnistParent]\n *   Ancestor type.\n */\n\n/**\n * @typedef {Visitor<Visited, Parent<Ancestor, Visited>>} BuildVisitorFromMatch\n *   Build a typed `Visitor` function from a node and all possible parents.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} Visited\n *   Node type.\n * @template {UnistParent} Ancestor\n *   Parent type.\n */\n\n/**\n * @typedef {(\n *   BuildVisitorFromMatch<\n *     Matches<Descendant, Check>,\n *     Extract<Descendant, UnistParent>\n *   >\n * )} BuildVisitorFromDescendants\n *   Build a typed `Visitor` function from a list of descendants and a test.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} Descendant\n *   Node type.\n * @template {Test} Check\n *   Test type.\n */\n\n/**\n * @typedef {(\n *   BuildVisitorFromDescendants<\n *     InclusiveDescendant<Tree>,\n *     Check\n *   >\n * )} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} [Tree=UnistNode]\n *   Node type.\n * @template {Test} [Check=Test]\n *   Test type.\n */\n\nimport {visitParents} from 'unist-util-visit-parents'\n\nexport {CONTINUE, EXIT, SKIP} from 'unist-util-visit-parents'\n\n/**\n * Visit nodes.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @overload\n * @param {Tree} tree\n * @param {Check} check\n * @param {BuildVisitor<Tree, Check>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @overload\n * @param {Tree} tree\n * @param {BuildVisitor<Tree>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @param {UnistNode} tree\n *   Tree to traverse.\n * @param {Visitor | Test} testOrVisitor\n *   `unist-util-is`-compatible test (optional, omit to pass a visitor).\n * @param {Visitor | boolean | null | undefined} [visitorOrReverse]\n *   Handle each node (when test is omitted, pass `reverse`).\n * @param {boolean | null | undefined} [maybeReverse=false]\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns {undefined}\n *   Nothing.\n *\n * @template {UnistNode} Tree\n *   Node type.\n * @template {Test} Check\n *   `unist-util-is`-compatible test.\n */\nexport function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {\n  /** @type {boolean | null | undefined} */\n  let reverse\n  /** @type {Test} */\n  let test\n  /** @type {Visitor} */\n  let visitor\n\n  if (\n    typeof testOrVisitor === 'function' &&\n    typeof visitorOrReverse !== 'function'\n  ) {\n    test = undefined\n    visitor = testOrVisitor\n    reverse = visitorOrReverse\n  } else {\n    // @ts-expect-error: assume the overload with test was given.\n    test = testOrVisitor\n    // @ts-expect-error: assume the overload with test was given.\n    visitor = visitorOrReverse\n    reverse = maybeReverse\n  }\n\n  visitParents(tree, test, overload, reverse)\n\n  /**\n   * @param {UnistNode} node\n   * @param {Array<UnistParent>} parents\n   */\n  function overload(node, parents) {\n    const parent = parents[parents.length - 1]\n    const index = parent ? parent.children.indexOf(node) : undefined\n    return visitor(node, index, parent)\n  }\n}\n","export interface Config {\r\n    blockCssClass: string;\r\n    titleCssClass: string;\r\n    types: Record<string, { svgIcon: string; title: string; cssClass: string }>;\r\n}\r\n\r\nexport const defaultConfig: Config = {\r\n    blockCssClass: 'markdown-alert',\r\n    titleCssClass: 'markdown-alert-title',\r\n    types: {\r\n        '[!NOTE]': {\r\n            // MIT License - Copyright (c) 2023 GitHub Inc. <https://github.com/primer/octicons>\r\n            svgIcon:\r\n                '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"currentColor\" viewBox=\"0 0 16 16\"><path d=\"M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"/></svg>',\r\n            title: 'Note',\r\n            cssClass: 'markdown-alert-type-note'\r\n        },\r\n        '[!TIP]': {\r\n            // MIT License - Copyright (c) 2023 GitHub Inc. <https://github.com/primer/octicons>\r\n            svgIcon:\r\n                '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"currentColor\" viewBox=\"0 0 16 16\"><path d=\"M8 1.5c-2.363 0-4 1.69-4 3.75 0 .984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75 0 0 1-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456 0 0 0-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863 0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751 0 0 1-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304 0-2.06-1.637-3.75-4-3.75ZM5.75 12h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM6 15.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Z\"/></svg>',\r\n            title: 'Tip',\r\n            cssClass: 'markdown-alert-type-tip'\r\n        },\r\n        '[!IMPORTANT]': {\r\n            // MIT License - Copyright (c) 2023 GitHub Inc. <https://github.com/primer/octicons>\r\n            svgIcon:\r\n                '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"currentColor\" viewBox=\"0 0 16 16\"><path d=\"M0 1.75C0 .784.784 0 1.75 0h12.5C15.216 0 16 .784 16 1.75v9.5A1.75 1.75 0 0 1 14.25 13H8.06l-2.573 2.573A1.458 1.458 0 0 1 3 14.543V13H1.75A1.75 1.75 0 0 1 0 11.25Zm1.75-.25a.25.25 0 0 0-.25.25v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25Zm7 2.25v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 9a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z\"/></svg>',\r\n            title: 'Important',\r\n            cssClass: 'markdown-alert-type-important'\r\n        },\r\n        '[!WARNING]': {\r\n            // MIT License - Copyright (c) 2023 GitHub Inc. <https://github.com/primer/octicons>\r\n            svgIcon:\r\n                '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"currentColor\" viewBox=\"0 0 16 16\"><path d=\"M6.457 1.047c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0 1 14.082 15H1.918a1.75 1.75 0 0 1-1.543-2.575Zm1.763.707a.25.25 0 0 0-.44 0L1.698 13.132a.25.25 0 0 0 .22.368h12.164a.25.25 0 0 0 .22-.368Zm.53 3.996v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 11a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z\"/></svg>',\r\n            title: 'Warning',\r\n            cssClass: 'markdown-alert-type-warning'\r\n        },\r\n        '[!CAUTION]': {\r\n            // MIT License - Copyright (c) 2023 GitHub Inc. <https://github.com/primer/octicons>\r\n            svgIcon:\r\n                '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"currentColor\" viewBox=\"0 0 16 16\"><path d=\"M4.47.22A.749.749 0 0 1 5 0h6c.199 0 .389.079.53.22l4.25 4.25c.141.14.22.331.22.53v6a.749.749 0 0 1-.22.53l-4.25 4.25A.749.749 0 0 1 11 16H5a.749.749 0 0 1-.53-.22L.22 11.53A.749.749 0 0 1 0 11V5c0-.199.079-.389.22-.53Zm.84 1.28L1.5 5.31v5.38l3.81 3.81h5.38l3.81-3.81V5.31L10.69 1.5ZM8 4a.75.75 0 0 1 .75.75v3.5a.75.75 0 0 1-1.5 0v-3.5A.75.75 0 0 1 8 4Zm0 8a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z\"/></svg>',\r\n            title: 'Caution',\r\n            cssClass: 'markdown-alert-type-caution'\r\n        }\r\n    }\r\n};\r\n","// Copyright (C) myl7\r\n// SPDX-License-Identifier: Apache-2.0\r\n// https://github.com/myl7/remark-github-beta-blockquote-admonitions/blob/c1833a503f4766cb4e1342bdf91322b7bc023412/src/index.ts\r\n// Changes made:\r\n// - Replaced the config with a new one that is compatible with this plugin.\r\n// - Admonitions cannot be nested.\r\n// - Added a icon to the title.\r\n\r\nimport type { Blockquote, Html, Paragraph, Text } from 'mdast';\r\nimport type { Plugin } from 'unified';\r\nimport type { BuildVisitor } from 'unist-util-visit';\r\nimport { visit } from 'unist-util-visit';\r\n\r\nimport { Config, defaultConfig } from '../config';\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nconst remarkGfmBlockquoteAdmonitionsPlugin: Plugin = () => (tree: any) => {\r\n    visit(tree, processNode(defaultConfig));\r\n};\r\n\r\nexport default remarkGfmBlockquoteAdmonitionsPlugin;\r\n\r\nconst processNode =\r\n    (config: Config): BuildVisitor =>\r\n    (node, _index, parent: import('unist').Node | undefined) => {\r\n        if (node.type != 'blockquote') {\r\n            return;\r\n        }\r\n        if (parent && parent.type == 'blockquote') {\r\n            return;\r\n        }\r\n\r\n        const blockquote = node as Blockquote;\r\n        if (blockquote.children[0]?.type != 'paragraph') {\r\n            return;\r\n        }\r\n\r\n        const paragraph = blockquote.children[0];\r\n        if (paragraph.children[0]?.type != 'text') {\r\n            return;\r\n        }\r\n\r\n        const text = paragraph.children[0];\r\n        const titleEnd = text.value.indexOf('\\n');\r\n        if (titleEnd < 0) {\r\n            return;\r\n        }\r\n\r\n        const textBody = text.value.substring(titleEnd + 1);\r\n        let title = text.value.substring(0, titleEnd);\r\n        // https://github.github.com/gfm/#whitespace-character\r\n        const whitespaceCharacter = /[ \\t\\v\\f\\r]+$/.exec(title);\r\n        if (whitespaceCharacter) {\r\n            title = title.substring(0, title.length - whitespaceCharacter[0].length);\r\n        }\r\n\r\n        const admonitionType = config.types[title];\r\n        if (!admonitionType) {\r\n            return;\r\n        }\r\n\r\n        text.value = textBody;\r\n\r\n        const paragraphTitleText: Text = {\r\n            value: admonitionType.title,\r\n            type: 'text'\r\n        };\r\n        const paragraphIcon: Html = {\r\n            type: 'html',\r\n            value: `<span class='icon'>${admonitionType.svgIcon}</span>`\r\n        };\r\n\r\n        const paragraphTitle: Paragraph = {\r\n            type: 'paragraph',\r\n            children: [paragraphIcon, paragraphTitleText],\r\n            data: { hProperties: { className: config.titleCssClass } }\r\n        };\r\n        blockquote.children.unshift(paragraphTitle);\r\n\r\n        blockquote.data = {\r\n            ...blockquote.data,\r\n            hProperties: { className: `${config.blockCssClass} ${admonitionType.cssClass}` },\r\n            hName: 'div'\r\n        };\r\n    };\r\n","import { markdownRenderer } from 'inkdrop';\nimport remarkGfmBlockquoteAdmonitionsPlugin from './remark-gfm-blockquote-admonitions';\n\nclass GfmBlockquoteAdmonitions {\n    activate = async () => {\n        if (markdownRenderer) {\n            markdownRenderer.remarkPlugins.push(remarkGfmBlockquoteAdmonitionsPlugin);\n        }\n    };\n\n    deactivate = async () => {\n        if (markdownRenderer) {\n            markdownRenderer.remarkPlugins = markdownRenderer.remarkPlugins.filter((plugin) => remarkGfmBlockquoteAdmonitionsPlugin !== plugin);\n        }\n    };\n}\n\nconst plugin = new GfmBlockquoteAdmonitions();\n\nmodule.exports = {\n    config: {},\n    activate() {\n        plugin.activate();\n    },\n    deactivate() {\n        plugin.deactivate();\n    }\n};\n"],"names":["convert","test","undefined","ok","castFactory","Array","isArray","anyFactory","propsFactory","typeFactory","Error","tests","checks","index","length","any","parameters","apply","check","checkAsRecord","all","node","nodeAsRecord","key","type","testFunction","value","parent","Boolean","looksLikeANode","call","color","d","empty","CONTINUE","EXIT","SKIP","visitParents","tree","visitor","reverse","is","step","factory","parents","name","tagName","Object","defineProperty","visit","result","subresult","offset","grandparents","toResult","children","nodeAsParent","concat","child","testOrVisitor","visitorOrReverse","maybeReverse","overload","indexOf","markdownRenderer"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}